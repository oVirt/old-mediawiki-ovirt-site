<!-- {{autolang|base=yes}} -->

= Using REST API in web UI =

== Summary ==
Replace current GWT RPC mechanism with implementation utilizing Engine REST API.

== Owner ==
* Name: [[User:Vszocs|Vojtech Szocs]]
* Email: <vszocs@redhat.com>

== Overview ==
oVirt web applications (i.e. WebAdmin and UserPortal) currently rely on GWT RPC mechanism to communicate with Engine backend. The exact RPC implementation in use, Direct-Eval RPC aka deRPC, [http://www.gwtproject.org/doc/latest/DevGuideServerCommunication.html#DevGuideDeRPC isn't officially supported anymore]; in fact, it never left "experimental" stage and is currently discouraged by GWT team.


Up to now, oVirt web UI used deRPC because it seemed to be the only GWT RPC implementation to fully support the kind of (Java) objects transferred between client and server. We've encountered [http://gerrit.ovirt.org/#/c/19122/ problems] when trying to use [http://www.gwtproject.org/doc/latest/DevGuideServerCommunication.html#DevGuideCreatingServices standard GWT RPC implementation], some of them occuring at runtime and others occuring during GWT compilation phase.


More generally, oVirt web UI uses GWT RPC mechanism because it allows sharing (Java) business entities and related objects between client and server. While seemingly convenient and easy at first, it led us into situation where client and server are coupled together by means of shared objects. GWT client code and its RPC implementation aim for JavaScript runtime environment (i.e. web browser) and therefore impose various restrictions to such shared objects, which in turn hinders the flexibility of Engine backend.


In addition to client/server coupling, the concept of using backend business entities in client code carries additional limitations, such as:
* cloning existing entity objects on client (manually copying all properties) whenever we need separate entity instance to work with
* tricking GWT compiler into thinking that all shared code is live (i.e. shouldn't be pruned from generated JavaScript output) to avoid deserialization errors on server
* inability to introduce additional logic into entity objects beyond basic getters/setters and simple operations, considering both client and server perspective


Conceptually, data displayed (or otherwise acted upon) by client is different than data managed by server; each one is used to achieve different goals. For example, from backend perspective, a "Host" business entity might hold data (and possibly additional logic) to represent host machine entity as a whole, cohesive object with well-defined purpose and responsibility. On the other hand, from client perspective, displaying data such as "Host name and number of running VMs on that host" would naturally lead to creating different kinds of entity representations suitable for client to display (or otherwise act upon); reusing backend business entities like "Host" or "VM" therefore doesn't seem appropriate from client perspective.


Simply put, client and server each serve different purposes, so the underlying data representations should reflect their purposes as much as possible. Sharing data representations (entities) between client and server restricts both client and server; in our case, server drives entity design and client makes best effort to adapt to that design. This typically leads to problems such as client requesting data updates and having to deserialize "heavy" objects just to display a small subset of received data to the user.


The primary goal of utilizing [[REST-Api|Engine REST API]] in oVirt web UI is to decouple client from server while using standard API to communicate with Engine backend. In addition, this should bring following positive side effects:
* server having full control over backend business entities and related objects, unconstrained and independent from any client
* client having the freedom to use whatever data representation is suitable, i.e. representation that overlays raw data returned by REST API
* less shared code means less code for GWT client to compile, improving compile times and reducing generated JavaScript footprint
* no need for GWT-specific hacks, such as tricking GWT compiler into thinking that all shared code is live
* not using Java <code>BackendLocal</code> interface directly, i.e. abstract away from query/action concept used internally by Engine backend


The secondary goal of this effort is to provide implementation utilizing REST API in a way that allows reuse by any JavaScript-based application, be it oVirt web UI, [[Features/UIPlugins|UI plugins]] or any other web application. This means the REST API will be used by more clients; considering the added potential for change requests driven by client-specific requirements, this should result in overall improvement of REST API itself.

== Design Proposal ==
Engine REST API is described by <code>api.xsd</code> (resource types) and <code>rsdl_metadata.yaml</code> (RESTful operations) within the <code>restapi-definition</code> module.


'''Engine JavaScript SDK''' would be a new module containing JavaScript code to interact with REST API. As we plan to separate oVirt web UI from Engine backend in terms of source repository and related aspects (i.e. build process and z-stream), the JavaScript SDK would be managed within the oVirt web UI source repository. In terms of packaging, oVirt web UI <code>rpm</code> would have dependency to JavaScript SDK <code>rpm</code>, i.e. JavaScript SDK must be installed in order to be used by web applications. Serving JavaScript SDK files via HTTP protocol can be implemented in different ways, one of them is to deploy JavaScript SDK as a separate web application to Engine backend, alongside oVirt web applications.

=== SDK Requirements ===

* '''simplicity''' - above anything else
* '''meaningful conventions''' - because things shouldn't be complicated too far beyond their [http://en.wikipedia.org/wiki/Essential_complexity essential complexity]
* '''backward compatibility''' - because SDK should work with older REST API versions too
* '''testability''' - employ consistent unit/behavior test convention (excluding any generated parts)
* '''extensibility''' - because SDK should evolve and improve over time

=== SDK Structure ===

JavaScript SDK would consist of two API layers:


* '''low-level API'''
** essentially a native (JavaScript) binding to REST API in terms of resource types (objects) and RESTful operations (functions)
** there would be a namespace per each supported REST API version, i.e. "complete" namespace for lowest version and "delta" namespaces for higher versions
** code ''could'' be generated at build time from REST API descriptor files
** code ''should'' be validated at build time against REST API descriptor files, i.e. make sure the low-level binding reflects supported REST API versions


* '''high-level API'''
** uses low-level API in a more abstract way suitable for clients to consume
** implements automatic REST API version detection in order to use appropriate low-level API namespace
** place for adding common and useful functionality to work with REST API, i.e. logical operations possibly spanning multiple physical REST API requests
** place for manual workarounds and any functionality desired but not supported by REST API
** code maintained manually
** code ''should'' be validated at build time to detect potential errors


JavaScript SDK would support the notion of backward compatibility with regard to version provided by REST API. In practice, this would mean:
* SDK version <code>X</code> + Engine version <code>X+1</code> → rely on backward compatibility of REST API
* SDK version <code>X</code> + Engine version <code>X-1</code> → use appropriate low-level API namespace mapping to older REST API version


In both cases mentioned above, web applications using JavaScript SDK should still work.

=== SDK Technology Proposal ===

Utilize [http://nodejs.org/ Node.js] platform to invoke tools suitable for JavaScript development:


* '''Common Tools'''
** [http://gruntjs.com/ Grunt] to automate task execution, such as running tests and producing output JavaScript
** [http://karma-runner.github.io/ Karma] to establish productive testing environment where a code change yields instant feedback
** [http://lisperator.net/uglifyjs/ UglifyJS] to optimize and minify output JavaScript
** [https://github.com/jsdoc3/jsdoc JSDoc] to generate SDK API documentation from source code


* '''Source Option A''' - CoffeeScript
** [http://coffeescript.org/ CoffeeScript] to avoid intricacies of JavaScript language (CoffeeScript compiles to JavaScript)
** [http://www.coffeelint.org/ CoffeeLint] to detect problems and enforce common code conventions


* '''Source Option B''' - vanilla JavaScript
** [http://www.jshint.com/ JSHint] to detect problems and enforce common code conventions

=== Client Consumption ===

Using JavaScript SDK in web applications would be as simple as adding following code into application's HTML page:


<pre>
<script type='text/javascript' src='http://path/to/sdk.js'></script>
</pre>


Placing the <code>script</code> element in HTML <code>head</code> and code utilizing the SDK in HTML <code>body</code> ensures the SDK gets loaded before use by client code.

== Comments and discussion ==
* Refer to [[Talk:Features/Design/Using_REST_API_In_Web_UI|design discussion page]].
