<!-- {{autolang|base=yes}} -->

== UI Plugins ==

=== Summary ===
This feature allows implementing custom User Interface (UI) plugins for oVirt web administration (WebAdmin) application.

=== Owner ===
* Name: [[User:Vszocs|Vojtech Szocs]]
* Email: <vszocs@redhat.com>
* IRC: vszocs at #ovirt (irc.oftc.net)

=== Current status ===
* In progress: Design draft
* Pending: Design implementation
* Pending: User (plugin authoring) documentation

=== Overview ===
oVirt WebAdmin application is a powerful tool to manage virtualization infrastructure, comprising components such as host and guest (virtual) machines, storage domains, etc.

There can be times when administrators want to expose additional features of their infrastructure through WebAdmin UI. This is achieved by writing custom plugins, which are invoked by WebAdmin application at key events during its runtime. As part of handling specific events, each plugin can extend or customize WebAdmin UI through the plugin API.

UI plugins are represented in [http://en.wikipedia.org/wiki/JavaScript JavaScript] language. This allows WebAdmin to invoke plugins directly on the client (web browser).

Following code snippet shows a minimalistic plugin:

<pre>
// Each plugin registers itself into pluginApi.plugins object, where the name of the property is the name of the plugin
pluginApi.plugins.myPlugin = {

    // Initialize the plugin, using an optional plugin configuration object, and report back when ready
    pluginInit: function(pluginConfig) {
        // Plugin lifecycle callback functions, such as the ready() function, are accessed through pluginApi object
        pluginApi.lifecycle(this).ready();
    },

    // Handle a specific application event, where the name of the function is the name of the event
    tableContextMenu: function(eventContext) {
        if (eventContext.entityType == 'VM') {
            // The eventContext.addItem function is specific to tableContextMenu event
            eventContext.addItem(
                'Show VM name and edit VM', // Item title
                function() {                // Item click handler function
                    Window.alert(eventContext.entity.name);
                    eventContext.itemAction('edit');
                }
            );
        }
    }

};
</pre>

In addition to the actual plugin code, each plugin can optionally have a configuration object associated. Plugin configuration objects are represented as [http://en.wikipedia.org/wiki/JSON JSON] data structures.

Following code snippet shows a sample plugin configuration object:

<pre>
{
    "customOption": "foo",
    "anotherOption": 123
}
</pre>

Last but not least, each plugin can optionally declare dependencies to 3rd party JavaScript libraries. Just like plugin configuration objects, plugin dependency declarations are represented as JSON data structures.

Following code snippet shows a sample plugin dependency declaration:

<pre>
{

    // Fetch jQuery library from remote URL
    "jQuery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js",

    // Fetch fooBar library from local filesystem (relative to plugin dependency declaration file location)
    "fooBar": "file://plugin-deps/foobar10.js"

}
</pre>

=== Plugin lifecycle ===
Following steps illustrate main aspects of the plugin lifecycle:
# User requests WebAdmin host page via web browser
# WebAdmin host page servlet detects all plugins
#* Proposed plugin file location: <code>/usr/libexec/ovirt/webadmin/extensions</code> (should be configurable through <code>vdc_options</code> table)
#* Proposed plugin file name convention: <code>pluginName-version.js</code>
# WebAdmin host page servlet looks up (optional) configuration files for detected plugins
#* Proposed configuration file location: <code>/etc/ovirt/webadmin</code> (should be configurable through <code>vdc_options</code> table)
#* Proposed configuration file name convention: <code>pluginName-version-conf.json</code>
# WebAdmin host page servlet looks up (optional) dependency declaration files for detected plugins
#* Proposed dependency file location: same as configuration file location
#* Proposed dependency file name convention: <code>pluginName-version-dep.json</code>
# For each detected plugin, WebAdmin host page servlet embeds plugin code, configuration and dependency information into the host page
#* Plugin code is wrapped in IIFE (Immediately Invoked Function Expression) for later execution
#* Plugin configuration is embedded unchanged (already a JSON object)
#* Plugin dependencies are parsed and processed in the following way:
#** For each remote URL dependency, a <code>script</code> tag with <code>src</code> attribute will be added to HTML <code>head</code> section of the host page
#** For each local filesystem dependency, a <code>script</code> tag containing library content will be added to HTML <code>head</code> section of the host page
#** Dependency object name will be used to avoid referencing the same dependency multiple times (as multiple plugins might have the same dependency)
# During WebAdmin startup, plugins are evaluated and registered into the global <code>pluginApi</code> object
#* The <code>pluginApi</code> object is managed and exposed by WebAdmin
#* The <code>pluginApi</code> object is the main entry point to plugin API
# WebAdmin will initialize all plugins by calling the <code>pluginInit</code> function
#* The <code>pluginConfig</code> parameter represents the (optional) plugin configuration object
#* Each plugin must report back as <code>ready()</code> before WebAdmin calls its event handling functions
# On key events during WebAdmin runtime, plugin event handling methods will be invoked on all plugins

=== Plugin API ===
WebAdmin plugin API has two kinds of functions, based on the context from which these functions are called: '''global''' (context-agnostic) and '''local''' (context-specific).

==== Global API functions ====
These functions are accessible through the global <code>pluginApi</code> object.

; Plugin lifecycle callback functions
:  Proposed API: <code>pluginApi.lifecycle(pluginObject).*</code>
:  Purpose: allow asynchronous (non-blocking) plugin communication, related to the plugin lifecycle

; WebAdmin global action functions
:  Proposed API: <code>pluginApi.action().*</code>
:  Purpose: allow plugins to invoke system-wide application actions, e.g. manipulate search string

; Plugin utility functions
:  Proposed API: <code>pluginApi.util().*</code>
:  Purpose: provide various utility functions, e.g. access oVirt engine configuration

==== Local API functions ====
These functions are accessible through the <code>eventContext</code> object, which WebAdmin provides to each event handler function.

Following the sample plugin presented in the [[#Overview]] section:
* <code>tableContextMenu</code> event triggers when the user right-clicks on selected item(s) within a data table (table context menu is about to be shown)
* <code>eventContext</code> object represents both event data (e.g. <code>eventContext.entityType</code>) and context-specific plugin API (e.g. <code>eventContext.addItem</code>)

API functions exposed by the <code>eventContext</code> object always depend on the corresponding application event.

=== Application event types ===
Generally speaking, each event represents an extension point, exposed by WebAdmin and consumed by plugins.

Here are some ideas for different event types:

; <code>uiInit</code>
:  Triggered when WebAdmin UI is fully initialized
:  Sample use case: add custom main tab to WebAdmin UI

; <code>tableContextMenu</code>
:  Triggered when a table context menu is about to be shown to the user
:  Sample use case: add custom item to table context menu

Feel free to [[Talk:Features/UIPlugins|discuss]] additional event types.

=== Implementation details ===
Technical notes on plugin infrastructure implementation:
* Create a dedicated (GIN-managed eager singleton) class for managing the global <code>pluginApi</code> object through [https://developers.google.com/web-toolkit/doc/latest/DevGuideCodingBasicsJSNI JSNI]
* Use [http://code.google.com/p/gwt-exporter/ gwt-exporter] for exporting GWT classes (including backend classes used in frontend) for use in UI plugins

=== Integration with 3rd party JavaScript libraries ===
Following code snippet shows the sample plugin presented in the [[#Overview]] section, modified for use with [http://jquery.com/ jQuery] and [http://jqueryui.com/ jQuery UI] libraries:

<pre>
// Using JavaScript IIFE (Immediately Invoked Function Expression) to map '$' sign to jQuery global object
// We don't use global '$' jQuery alias to avoid conflicts with other libraries (e.g. Prototype library also defines '$' global variable)
(function( $ ) {

    pluginApi.plugins.myPlugin = {

        pluginInit: function(pluginConfig) {
            pluginApi.lifecycle(this).ready();
        },

        tableContextMenu: function(eventContext) {
            if (eventContext.entityType == 'VM') {
                eventContext.addItem('Show VM name and edit VM', function() {
                    // Show a jQuery UI modal dialog
                    $('<div/>')
                        .html(eventContext.entity.name)
                        .dialog({
                            title: 'VM name',
                            modal: true,
                            buttons: {
                                'OK': function() {
                                    $(this).dialog('close');
                                    eventContext.itemAction('edit');
                                }
                            }
                        });
                });
            }
        }

    };

})( jQuery );
</pre>

=== Documentation / External references ===
* [[Features/UIPluginsOriginalDesignNotes|Original design notes]]

=== Comments and Discussion ===
* Refer to [[Talk:Features/UIPlugins|discussion page]].

[[Category:Feature]]
