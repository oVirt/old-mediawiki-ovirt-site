<!-- {{autolang|base=yes}} -->

== General ==
Supervdsm is responsible for all privileged operations. Currently Supervdsm is managed (started and restarted) by unprivileged process 'vdsm'. To perform that, Vdsm process runs privileged operations, manage process that runs as root, and communicate with it by external UDS. All that leads to races between new and old instances of the process. Aim of this feature is to get Vdsm to be a pure unprivileged process and simplify the handling of crashes and re-establish communication between Vdsm and Supervdsm after failures.

== Owner ==
<!--This should link to your home wiki page so we know who you are-->
* Name: [[User:Royce Lv| lvroyce]]
* Name: [[User:Yaniv Bronheim|ybronhei]]
<!-- Include you email address that you can be reached should people want to contact you about helping with your feature, status is requested, or  technical issues need to be resolved-->
* Email: <lvroyce@linux.vnet.ibm.com>
* Email: <ybronhei@redhat.com>

== Current status ==
*current solution<br />
# Vdsmd.init start vdsm with user “vdsm” <br />
# Launch supervdsm when it is not running by sudo command<br />
# Vdsm tries to call supervdsm<br />
# When authentication error, re-launch (kill old instance and initiate new one), other errors just raise<br />
# When vdsm dies, supervdsm distinguish it and kill itself automatically, next vdsm instance starts new supervdsm process<br/>
[[File:First launch.jpeg]][[File:Normal call.jpeg]]    [[File:Auth error.jpeg]] 
*Current problems<br />
# Unprivileged vdsm and proxy need to call previleged “sudo launch” and “sudo kill”<br />
# Redundent key between vdsm and supervdsm as they are parent and child<br />
# Error handling cause races between old and new instance of supervdsm and vdsm<br />

* Last updated: {{CURRENTMONTHNAME}} {{CURRENTDAY}}, {{CURRENTYEAR}}<!--This is markup for current date, do not change-->

== Proposed changes ==
<!-- Expand on the summary, if appropriate.  A couple sentences suffices to explain the goal, but the more details you can provide the better. -->
*Proposal A:[http://gerrit.ovirt.org/gitweb?p=vdsm.git;a=commit;h=976dbb13e6cd8136b12ed58ccd2a5176b730bddf patch for proposal A]
# Vdsmd.init starts vdsm as root
# Vdsm forks supervdsm server and then drop privilege
# When vdsm exit, supervdsm probe vdsm heart beat stop and exit
# Vdsm call supervdsm may discover supervdsm server exit, vdsm will exit itself and restart

*Proposal B:[http://gerrit.ovirt.org/gitweb?p=vdsm.git;a=commit;h=033ef4bc73dbbb36dd8180049626e7f4cde56334 patch for proposal B]
# vdsmd.init starts supervdsm as root
# supervdsm forks vdsm as child process
# when vdsm dies, supervdsm kill itself and start over again
# when supervdsm, vdsm distinguish that and kill itself

*proposal C:[http://gerrit.ovirt.org/#/c/11051/patch for proposal C] -> '''Selected solution.'''
# Vdsmd.init starts vdsm as vdsm user
# Supervdsmd.init starts supervdsm as root
# Both services are managed by respawn and start over again after crash
# When vdsm cannot connect to supervdsm socket, it restarts supervdsm service 3 tries

==Exception flows to consider==
*Exception flows:
# One of supervdsm server export function raise error 
#* expected result: raise to proxy caller 
# Supervdsm main thread died during a call (need to test)
#* expected result: raise to proxy caller EOFError
#* supervdsm restarts automatically and vdsm call to the same function again
# supervdsm main thread killed before call
#* expected result:restart supervdsm and call
# vdsm crash
#*supervdsm stays up and vdsm re-establish communication to supervdsm socket

==Proposal comparison==
*Exception flows need attention：
# First launch
#* A: Supervdsm server process lauched by priviledged vdsm, then vdsm drop priviledge
#* B: Supervdsm server process lauched by vdsmd.init
#* C: Supervdsm server process launched by supervdsmd.init
# One of supervdsm server export function raise error 
#* A:Just raise to Proxy Caller
#* B:Just raise to Proxy Calller
#* C:Just raise to Proxy Calller
# Supervdsm main thread killed when calling
#* A: Discover when call return EOFError and then restart 
#* B: Vdsmd as supervdsm's child should kill itself when receive EOFError
#* C: Supervdsmd restarts supervdsmServer and vdsm call the method again
# Supervdsm main thread killed before call
#* A: Discover when "isRunning" raise error, then restart
#* B: Vdsmd as supervdsm's child should be killed when next time supervdsm start, or vdsmd also has a heart beat scheme for super vdsm
#* C: Supervdsmd restarts supervdsm
# Supervdsm server thread killed(not started) before call
#* A: Connect error, restart
#* B: Supervdsm restart itself
#* C: Supervdsmd restarts, if still doesn't work for 3 reties vdsm call panic and restarts
# Vdsm process died
#* A: Supervdsm has  heart beat for vdsm to kill itself
#* B: Supervdsm joined vdsm and restart all over
#* C: Nothing.

As we can see from the above, proposal B will involve more complex logic when supervdsm died, vdsm will probe its heart beat or supervdsm should kill vdsm for next time, but vdsm still in the middle of some operations, possible inconsistent situation will happen.
Proposal C is intuitive, easier, and less  complex than both A and B proposals. The main odd is that every code update of vdsm we need restart both services, as they both share same code.

== Benefit to oVirt ==
<!-- What is the benefit to the oVirt project?  If this is a major capability update, what has changed?  If this is a new feature, what capabilities does it bring? Why will oVirt become a better distribution or project because of this feature?-->
# Clean vdsm priviledge usage
# Clean and stable vdsm/supervdsm exception flow and races

== Documentation / External references ==
<!-- Is there upstream documentation on this feature, or notes you have written yourself?  Link to that material here so other interested developers can get involved. Links to RFEs. -->
* TODO: paste corresponding bugzilla link and gerrit link here

== Comments and Discussion ==

This below adds a link to the "discussion" tab associated with your page.  This provides the ability to have ongoing comments or conversation without bogging down the main feature page

* Refer to [[Talk:Your feature name]]  <!-- This adds a link to the "discussion" tab associated with your page.  This provides the ability to have ongoing comments or conversation without bogging down the main feature page -->

[[Category:Feature]]
[[Category:Vdsm]]
