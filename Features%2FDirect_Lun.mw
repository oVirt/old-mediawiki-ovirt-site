== Introduction ==

Any block device can be used as local disk in the VM specifying it's GUID.

== OVIRT flows ==

These flows should be supported from the GUI.
* Import disk
# Discovery targets
# Connect to the target
# Get device list
#* Return GUID and connection parameters
# Choose a block device:
#* default: Unattached devices
#* option: From a VM (+ plug)

* Attach to VM (+ plug)
# Select VM
# Select or import disk
# Plug it
#* If the VM is not running, the disk target connection should be added to the required connections for the VM.
#* If the VM is running:
#*# Engine should assert that the backing storage target is reachable or connect it to the host running the VM.
#*# Do hot plug.

* Run VM
# Async manage disk target connection on [[#Notes|all]] hosts for all the required disks/domains.
# Wait on connection on the preferred host.
#* If succeded, RunVM
#* If not immediately try next hosts until success.

* Hot plug
# Engine should assert that the backing storage target is reachable or connect it to the host running the VM.
# Do hot plug.

* Hot unplug
# Do unplug.
# Unmanage the target disk connection.

* Migration
# Engine should assert that the backing storage target is reachable or connect it to the VM [[#Notes|'''destination host''']].
# Do migration.

* Stop VM
# Stop the VM.
# Unmanage the target disk connection.

* HA
# Engine should assert that the backing storage target is reachable or connect it to the VM [[#Notes|'''destination host''']].
# Restart the VM

== Engine - VDSM API ==

A new API is added for this feature.

The API specifies a block device by GUID or UUID, instead of the PDIV quartet of a regular [[Live_Snapshots#Introduction|VDSM volume]].

Other disk device parameters are the same as in VDSM volumes.

<pre>
'devices': [   
       {'type': 'disk',
        'device': 'disk',
        'iface': 'virtio|ide',
        'index': <int>,                            <--- disk index unique per 'iface' virtio|ide
        'GUID': 'shared disk GUID',                <--- Should be passed instead the PDIV
        'address': 'PCI|IDE address dictionary',   <--- PCI = {'type':'pci', 'domain':'0x0000', 'bus':'0x00', 'slot':'0x0c', 'function':'0x0'} ,  
                                                        IDE = {'type':'drive', 'controller':'0', 'bus':'0', 'unit':'0'}
                                                        Only if known.
        'format': 'raw',                           <--- Only raw disks are supported.
        'bootOrder': <int>,                        <--- global boot order across all bootable devices
        'propagateErrors': 'off',
        'shared': 'True|False',                    <--- whether disk is shared
        'optional': 'True|False',                  <--- whether disk is optional (VM can be run without optional disk if inaccessible)
                                                        THIS FEATURE IS UNSUPPORTED YET!
        'readonly': 'True|False'}
</pre>

The ''GUID'' is returned in the getDeviceList response.

VM disks specified this way should support all the modes and features, i.e Shared Hot-Plug, etc.

See [[Features/Design/StableDeviceAddresses|Stable Device Addresses]] for the complete device interface.

== Engine considerations ==
=== The vDisk entity ===
* Engine should have an abstraction that contains: 
** Backing storage (returned by getDeviceList or equivalent).
** Connection to the backing storage.
** The image stack (history).
** Other Engine required info.

This object will be called a '''vDisk'''.

A vDisk represents the time evolution of a VM or floating disk and extra Engine data.

It's started from a ''single'' block device returned by getDeviceList (or equivalent function).

Creating a new entity from the same block device should result in the [[#Notes|same]] vDisk entity.

Successive snapshots creates new (time stamp, image UID) entries.

The image UID can be transferred to runVM, hot-plug, migrate, etc.

Before starting of any operations Engine should assert that the [[#Notes|'''destination host''']] is connected to the target

=== The Engine design ===

* Adding of new lun to vm: 
** Choose some host
** Connect a lun in asynchronous way to every host in pool
** Wait for success connection with first host, at case it failed check a result for a next host in list
** When connection with host successes, engine will consider that all other hosts successes to connect with lun, engine will not wait for results for all

* Changes at scenarious 
** During RunVm and MigrationVm engine will check if appropriate host is connected to lun of vm, if yes the vm will be run or migrate, if host is not connected a choosen host will not be calculated as missed try

== Notes ==
# If two vDisks can be based on the same backing storage is still on discussion.
# A short set in the future.
# <dt> Destination host
<dd> the host running or that will run the VM.
