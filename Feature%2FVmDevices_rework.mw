= VmDevices rework =

== Summary ==
This feature will track the refactoring and reworking of VmDevices inside VDSM.

== Owner ==
* Name: [[User:Martin Polednik| Martin Polednik]]
* Email: [mailto:mpolednik@redhat.com mpolednik@redhat.com]

== Current status ==
* Last updated date: Thu Apr 28 2015
* [https://gerrit.ovirt.org/#/q/status:open+project:vdsm+branch:master+topic:device_isolation gerrit topic branch]

== What is wrong with current state ==
* Information duplication - the data is kept in device objects AND self.conf['devices'] dictionary
* Most of the functionality is in the VM class itself (while device modules would be more suitable)
* Above goes for legacy device configuration and getUnderlying* family of methods
* The code is not well tested
* Libvirt XML parsing and processing is dumb - missing orchestration object to delegate XML chunks to devices themself

== Formal naming system ==
Currently, there are multiple representations of a device in its lifetime inside VDSM. In order to work with them,
it makes sense to formalize the naming of representations:

* <code>{'device': '...', 'type': '...', 'deviceId', ...}</code> is the format in which the device is specified in configuration sent from engine. We will call this a <i>device specification</i> <code>dev_spec</code>.
* <code>[device_spec]</code> denotes a list of device specifications. Let's call it <i>device specification list<i> <code>dev_spec_list</code>.
* Legacy VM conf section will be called <i>legacy conf</i>.
* And current VM conf section <i>conf</i>.
* <code><Sound object at...></code> is python object representing the device, <i>device object</i> <code>dev_object</code> and plural <i>device objects</i> <code>dev_objects</code>.
* <code>{device_type: [device_object]}</code> is an internal format of VM's _devices, that we will call <i>device mapping</i> <code>dev_map</code>.
* <code>{device_type: [device_spec]}</code> is a format used for transition from device specification list to device mapping - <i>device specification map</i> <code>dev_spec_map</code>.
* When initializing an empty structure, prefix with <code>empty</code>.

* Type of the device is <code>dev_type</code>.
* Class of the device is <code>dev_class</code>.

The <code>dev_</code> prefix can be omitted if for each occurrence of function/method call there exists a *device* word in one of the namespaces accessed.

 PEP8: we're trying to make the code as consistent as possible while slowly converting everything to be pep8 compliant. Therefore, following rules can be used:
* use pep8 conventions in new modules,
* use pep8 conventions in old module if the code is about to move,
* stay consistent within the file.

== Phase 1 ==
Using the names defined above, the first phase of devices rework will consist of removing device-specific code in vm.py and moving it to vmdevices/${device}.py, using consistent naming
conventions. One of the first thing is isolating device object creation from _run method of VM class. This will allow us to work with multiple device objects in unit tests, possibly leading
to better tests.

=== Phase 1.1 ===
VM class's _run method contains a code that, given a device mapping, generates device objects and stores them in VM._devices attribute. The first step is simply moving this code to a new method
and naming it correctly: <code>devObjectsFromDevMap</code> (lowerCamelCase for the sake of consistency). This is also opportunity to rename <code>buildConfDevices</code> to something
a bit more descriptive and accurate: <code>devSpecMapFromConf</code>. The flow inside VDSM will therefore be
<pre>
def _run():
    ...
    dev_spec = devSpecMapFromConf()
    ...
    self._devices = devMapFromDevSpecMap(dev_spec)
</pre>

=== Phase 1.2 ===
Legacy configuration had lower number of devices than current conf has. There exists a code that, given legacy conf, returns correct specification list. These devices are Drive, NetworkInterfaceController, Sound, Video, Graphics and Controller. The legacy methods called getConf${device} are currently in VM class. One possible destination for these methods are
the device modules (not the classes). Moving them and respecting pep8 yields module functions <code>spec_list_from_legacy_conf</code>. This also requires purification of the methods,
which isn't exactly complex because each one of them contains reference to VM's conf and possibly arch. Therefore, to make them easily iterable, the final signature should be <code>spec_list_from_legacy_conf(conf, arch)</code>.

== Final Goal ==
The device classes and modules would hold all methods, data and classes necessary to fully maintain the device. vm.py file, with a bit of luck, can be reduced by up to ~700 lines. conf['devices'] and _devices would be merged into a single entity that provides interface for legacy access but internally keeps all the information in device objects.
