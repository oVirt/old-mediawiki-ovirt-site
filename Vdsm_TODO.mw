= What Can You Do for Vdsm =

== Cleanup ==
* <tt>pylint -E `git ls-files | grep '.py$'`</tt> makes me cry. A lot of it is "only" about bad style, but we should clear it up and add it to our <tt>make check-local</tt>. We should grow up and pass <tt>pychecker</tt> too.

* Improve Vdsm portability. We are very much Fedora-centric at best. Do you want to have Vdsm on your pet distribution? Own that port!

* remove all usage of <tt>sudo</tt>, and replace with specific calls to <tt>superVdsm</tt>.

* vdsm-tool should assume responsibility on hairy stuff such as [http://bugzilla.redhat.com/547424 configuring multipath], which should not be the business of Vdsm proper.

* vdsm/sampling.py: stop storing self._ifids and _rates in the thread. Rate can sit in the interfaces dict per sample.

* setupNetwork: stop passing kwarg to ifcfg files blindly.

== Testing ==

* enable coverage during Jenkins tests.

* run developer jobs on patches with +2 and V+1.

* Add <tt>`make distcheck`</tt> to Jenkins's jobs.

* make <tt>getAllVolumesTests</tt> more meaningful, not only counting the number of volumes, but testing the image structure.

* Wrap all tests and fail a test that leaves an open file descriptor behind.

* add a unit test for qemuimg.rebase.

* test getVdsStats in network functional tests.

* test that a dhcp-configured address is changes upon server request

* make @permutations nestable

* test fileSD.scanDomains()

* pass test name as a hidden arg (sequence ID, maybe) to be loggeed in vdsm.log

* add migration tests

* test cannonizeHostPort

== Features ==
* Support striping for disk images.

* let Vdsm install and run on hosts with no iscsid (report that iscsi is missing to Engine?)

* start Vdsm only when it receives a request (integrate with systemd)

=== Networking ===

* <strike>work in conjunction with Network Manager.</strike> works in F20.

* report current bond master

* Allow editing VM networks with vNICs running on them, i.e., keeping the bridge and just replacing what's underneath it in the host side.

* Modify vdsm-tool restore-nets so that the management network (or the network with the default IPv4 route) is the last to be taken down and the first to be taken up to minimize the connectivity loss (very useful when accessing the machine remotely).

* Split off the network restoration from vdsm startup so that it is performed in a different init service. This vdsm-network-restoration service should be oneshot and happen before network.service.

* Fine-grained control on network-specific routes.

* Allow multiple setting IPv4 and IPv6 addresses per network device. (API changes is needed; we report multiple ipv6 addresses).

* DNS in API

* get a single dump of all libvirt networks (no libvirt API for it yet...)

* fix privatevlan hook http://gerrit.ovirt.org/#/c/24195/

* before_ifcfg_write hook point + ifcfg hook

* returm more fine grained error messages at the API level

* pslit vdsm-restore-net-config from vsdmd

* IPv4 routing table Id hash mechanism
** change the 'network' argument in routes to 'link scopee route'

* move source routing info to route.py (which uses netlink instead of using the default configurator). this will also simplify StaticSourceRoute

* support IPv6 in source routing

* use ElementTree/cElementTree/lxml instead of minidon in libvirt.py

* models: support multiple IPv4 and/or IPv6 addresses

* use setupNetworks internally by addNetworks and delNetworks to unify flows.

* edit bridges (allow editing of everything under the bridge) to allow editing a network without discoonecting inter-vm connectivity.

* allow adding DNS configuration on static IP

* stop reading ifcfg files in netinfo.py

== refactoring ==
* In vm.py, libvirtvm.py, clientIF.py  there is a mess of prepare*Path functions (end their respective teardowns), which is too complex to fathom. We have to convert all drive specifications (PDIV,GUID,path) into Drive object at the API entry.

* We store VM configuration/state in 3 different places: vm.conf (and its on-disk persistency), vm object and its vm.devices[], and within libvirt. This creates a hell of inconsistency problems. Think of Vdsm crashing right after hotpluggin a new disk. The added disk would not be monitored by Vdsm post-restart and not even by destination vdsm if the VM is migrated.

* lvm.PV.guid is devicemapper-owned piece of information; lvm has nothing to do with it, and jumps through [http://gerrit.ovirt.org/2940 hoops] to produce it. Instead, it should be produced by devicemapper and consumed directly by blockSD.

* <strike>Define an API.VMState "enumeration" and use API.VMState.UP instead of the string 'Up'.</strike>

* <strike>factor betterPopen and betterThreading out of vdsm. They deserve a pipy review under the names [https://pypi.python.org/pypi/cpopen cPopen] and [http://pypi.python.org/pypi/pthreading pthreading] respectively.
https://bugzilla.redhat.com/show_bug.cgi?id=903246</strike>

* factor the task framework out of storage. Networking may need it, too.

* make storage_mailbox testable; use bytearrays instead of 1MiB strings; use fileUtils.DirectFile instead of forking /bin/dd all the time.

* split VM monitoring threads out of core Vdsm. Monitoring process would write to a memory-mapped file the most up to date values, which can be read by Vdsm on demand. This would reduce thread contentions in Vdsm and may simplify the code.

* split fenceNode to its own testable module.

== Bugzilla ==

* pick one of the [https://bugzilla.redhat.com/buglist.cgi?action=wrap&bug_file_loc=&bug_file_loc_type=allwordssubstr&bug_id=&bug_id_type=anyexact&chfieldfrom=&chfieldto=Now&chfieldvalue=&component=vdsm&deadlinefrom=&deadlineto=&email1=&email2=&emailtype1=substring&emailtype2=substring&field0-0-0=flagtypes.name&keywords=&keywords_type=allwords&longdesc=&longdesc_type=allwordssubstr&short_desc=&short_desc_type=allwordssubstr&status_whiteboard=&status_whiteboard_type=allwordssubstr&type0-0-0=notsubstring&value0-0-0=rhel-6.2.0&votes=&=&bug_status=NEW NEW bugs], post a patch to [http://gerrit.ovirt.org gerrit], and make the bug yours.

[[Category:Vdsm]]
