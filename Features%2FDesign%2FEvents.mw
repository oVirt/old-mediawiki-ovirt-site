<!-- {{autolang|base=yes}} -->

== Event processing built on top of JSON-RPC ==

{{Feature|name=Event mechanism to send events from the host to the engine|modules=vdsm, engine|status=In Development|version=3.6.0}}

=== Summary ===
Engine to vdsm communication was always initiated by an engine. Even when we execute long running tasks on vdsm there is polling mechanism to check status of a task. This behavior creates communication overhead and we want to address this issue by sending messages from vdsm and breaking current mechanism of rpc. This feature provides infrastructure to send messages from vdsm and to receive them on an engine side. We are not going to modify existing xmlrpc and it is still supported in 3.6. 

=== Owner ===

* Name: [[User:Pkliczewski| Piotr Kliczewski]]
* Email: <pkliczew@redhat.com>

=== Current status ===
* Last updated on {{REVISIONYEAR}}-{{REVISIONMONTH}}-{{REVISIONDAY2}} by [[User:{{urlencode:{{REVISIONUSER}} | WIKI}}]] <!--This is markup for the date on which the current page was last changed, do not change-->

=== Overview ===
In 3.5 release we introduced [[Features/Design/JsonRpc3.5|jsonrpc]] which provided asynchronous behavior. We are going to leverage it in order to provide vdsm side messages. We refer to such messages as events generated by vdsm. Constant flow of events is delivered to different parts of an engine by using [http://www.reactive-streams.org/ reactive streams] abstractions. Each event can be delivered to one or more vdsm clients by using stomp level subscriptions.

=== Event structure ===
3.5 implementation uses stomp protocol to send [http://www.jsonrpc.org/specification jsonrpc] defined messages. As part of this effort we are going to use notification structure as defined in the specification.

Here is the structure of an event:

 SEND
 destination: <queue/topic>
 content-type:text/json
 content-length: <length>
 content-encoding: <token as defined by IANA>
 {
      "jsonrpc": "2.0",
      "method": "<receiver>|<component>|<operation_id>|<unique_id>",
       params": {
        <contents>
     }
 }
 ^@

<queue/topic> defines a destination to which we deliver events. It is delivered to all the clients which subscribed to this destination. At the moment event destination is
defined in config.py using 'event_queue' property and value of it is an engine response: 'jms.topic.vdsm_responses'

<receiver>|<component>|<operation_id>|<unique_id> defines subscription id which is used to match engine side subscription.

<contents> defines place where we send data as part of an event.

=== Subscription identifier ===
Subscription id is used to uniquely identify an event so entity receiving is able to match it to subscribed entities. The idea behind this id is to use information known by all the parties. Here is how we define each of parts:

<receiver> contains ip address or host name and it is provided by client side (engine) when it is received. 

<component> contains information about which component generated the event such as virt/storage etc.

<operation_id> contains information about operation. In order to ease migration from rpc based communication to events we can use operation names such as Image_move, Volume_copy etc.

<unique_id> contains information about the object on which we perform operation like image, volume or vm uuid.

From subscription perspective it is possible to specify '*' as part of subscription id which means that we do not care what is the value in this part.

'*|virt|*|8839ddac-d833-4b0d-b7e2-4517fd100c8f' - for this subscription id we are receive events which match component 'virt' and are generated for vm id '8839ddac-d833-4b0d-b7e2-4517fd100c8f '. Receiving all possible events by specifying '*|*|*|*' filter is not supported.
